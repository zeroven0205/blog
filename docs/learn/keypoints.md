### 记录一些小知识点
* 有没有遇到过window.$("body").scrollTop(0)  在安卓机子失效的问题
* 问下，项目用了timsdk，font-family的值为tim tim是自定义的吗？———— 可以自定义
* 请求头里的no-cache表示浏览器不想读缓存，并不是说没有缓存。一般在浏览器按ctrl+F5强制刷新时，请求头里就有这个no-cache，也就是跳过强缓存和协商缓存阶段，直接请求服务器。（如果直接按F5的话，请求头是max-age=0，只跳过强缓存，但进行协商缓存）
* 请求头Cache-Control：no-cache表示不使用缓存
* 响应头Cache-Control：no-cache表示客户端不缓存
* 
* 请问一下，webpack开发模式下，一般都是使用style-loader,把css编译到js中，然后动态的插入style标签，那如果我在开发模式下使用mini-css-extract-plugin直接把css分离成单个文件，有什么区别呢。或者说为什么社区普遍采用style-loader + style的方式，而不是分离文件的方式


有没有在小程序里遇到，输入连续的字母，但在input框内没有实时获取到值，需要选择，或者blur时才能获取到
bindinput

VueConf 2019-上海群1 2020-04-01 Hugh胡晓军
PHP官方网站页面，其中有一个模块需要定时更新数据，被模拟数万级别用户、高并发请求访问攻击拖库，打满带宽打爆CPU，宕掉数据库服务接口

不行就执行脚本把这个页面数据都直接用canvas 画好了 存七牛 直接静态展示图片 有新的时候就画好了，画图的页面不对外爆露 这样先用着



IndexdDB是HTML5的本地存储，把一些数据存储到浏览器（客户端）中，当与网络断开时，可以从浏览器中读取数据，用来做一些离线应用。

Cookie 通过在客户端 ( 浏览器 ) 记录信息确定用户身份，最大为 4 kb 。

url 参数用的是 get 方法，从服务器上获取数据，大小不能大于 2 kb 。

Session 是服务器端使用的一种记录客户端状态的机制；
会话级存储，当网页会话关闭，存储内容被销毁

post 是向服务器传送数据，数据量较大。

local Storage 也是 HTML5 的本地存储，将数据保存在客户端中（一般是永久的）,需要手动清除缓存

javascript 语言特性中，有很多方面和我们接触的其他编程语言不太一样，比如说，javascript语言实现继承机制的核心就是【prototype】，而不是Java语言那样的类式继承。Javascript 解析引擎在读取一个Object的属性的值时，会沿着【原型链】向上寻找，如果最终没有找到，则该属性值为【undefined】； 如果最终找到该属性的值，则返回结果。与这个过程不同的是，当javascript解析引擎执行“给一个Object的某个属性赋值”的时候，如果当前Object存在该属性，则改写该属性的值，如果当前的Object本身并不存在该属性，则赋值该属性的值 。



IndexedDB是HTML5-WebStorage的重要一环，是一种轻量级NOSQL数据库;一个网站可能有一个或多个 IndexedDB 数据库，每个数据库必须具有惟一的名称。一个数据库可包含一个或多个对象存储。一个对象存储（由一个名称惟一标识）是一个记录集合。每个记录有一个键 和一个值。该值是一个对象，可拥有一个或多个属性。键可能基于某个键生成器，从一个键路径衍生出来，或者是显式设置。一个键生成器自动生成惟一的连续正整数。键路径定义了键值的路径。它可以是单个 JavaScript 标识符或多个由句点分隔的标识符。 Web Storage数据完全存储在客户端，不需要通过浏览器的请求将数据传给服务器，因此相比cookie来说能够存储更多的数据，大概5M左右。单个cookie在客户端的限制是3K，就是说一个站点在客户端存放的COOKIE不能3K。 具体来说cookie机制采用的是在客户端保持状态的方案，而session机制采用的是在服务器端保持状态的方案。 (1).首先是"GET方式提交的数据最多只能是1024字节"，因为GET是通过URL提交数据，那么GET可提交的数据量就跟URL的长度有直接关系了。而实际上，URL不存在参数上限的问题，HTTP协议规范没有对URL长度进行限制。这个限制是特定的浏览器及服务器对它的限制。IE对URL长度的限制是2083字节(2K+35)。对于其他浏览器，如Netscape、FireFox等，理论上没有长度限制，其限制取决于操作系统的支持。 　　注意这是限制是整个URL长度，而不仅仅是你的参数值数据长度。[见参考资料5] 　　(2).理论上讲，POST是没有大小限制的，HTTP协议规范也没有进行大小限制，说“POST数据量存在80K/100K的大小限制”是不准确的，POST数据是没有限制的，起限制作用的是服务器的处理程序的处理能力。 　　对于ASP程序，Request对象处理每个表单域时存在100K的数据长度限制。但如果使用Request.BinaryRead则没有这个限制。 　　由这个延伸出去，对于IIS 6.0，微软出于安全考虑，加大了限制。我们还需要注意： 　　　　 1).IIS 6.0默认ASP POST数据量最大为200KB，每个表单域限制是100KB。 　　　　 2).IIS 6.0默认上传文件的最大大小是4MB。 　　　　 3).IIS 6.0默认最大请求头是16KB。 　　IIS 6.0之前没有这些限制。[见参考资料5] 　　所以上面的80K，100K可能只是默认值而已(注：关于IIS4和IIS5的参数，我还没有确认)，但肯定是可以自己设置的。由于每个版本的IIS对这些参数的默认值都不一样，具体请参考相关的IIS配置文档。